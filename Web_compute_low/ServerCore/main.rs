/* ==========================================================================
   ğŸ“ƒ æ–‡ä»¶åŠŸèƒ½ : Web Compute Low é™æ€èµ„æºæœåŠ¡å™¨
   âš¡ é€»è¾‘æ‘˜è¦ : ä½¿ç”¨ Axum æä¾›é«˜æ€§èƒ½çš„é™æ€æ–‡ä»¶æœåŠ¡ (HTML/JS/CSS/Assets)ã€‚
   ğŸ’¡ æ˜“æ‡‚è§£é‡Š : è¿™æ˜¯ä¸€ä¸ª "æ–‡ä»¶æŸœå°"ï¼Œä¸“é—¨è´Ÿè´£æŠŠç½‘é¡µæ–‡ä»¶é€’ç»™æµè§ˆå™¨ã€‚
   ğŸ”‹ æœªæ¥æ‰©å±• : æ”¯æŒ HTTP/2ï¼Œæ”¯æŒ Gzip å‹ç¼©ã€‚
   ğŸ“Š å½“å‰çŠ¶æ€ : æ´»è·ƒ (æ›´æ–°: 2025-12-16)
   ğŸ§± ServerCore/main.rs è¸©å‘è®°å½• :
      1. [2025-12-04] [å·²ä¿®å¤] [è·¯å¾„é—®é¢˜]: é»˜è®¤ ServeDir è·¯å¾„ä¸º "."ï¼Œéœ€ç¡®ä¿åœ¨æ­£ç¡®çš„å·¥ä½œç›®å½•ä¸‹è¿è¡Œã€‚
      2. [2025-12-16] [å·²ä¿®å¤] [ç¼“å­˜é—®é¢˜]: æµè§ˆå™¨ç¼“å­˜æ—§JSæ–‡ä»¶ -> æ·»åŠ  Cache-Control: no-cache å¤´
   ========================================================================== */

use axum::{
    Router,
    middleware::{self, Next},
    http::{Request, header},
    response::Response,
    body::Body,
};
use std::net::SocketAddr;
use tower_http::cors::CorsLayer;
use tower_http::services::ServeDir;

// =============================================================================
//  ğŸ‰ ç¦ç”¨ç¼“å­˜ä¸­é—´ä»¶
//
//  ğŸ¨ ç”¨é€”:
//      ä¸ºæ‰€æœ‰å“åº”æ·»åŠ  Cache-Control: no-cache å¤´ï¼Œé˜²æ­¢æµè§ˆå™¨ç¼“å­˜æ—§æ–‡ä»¶ã€‚
//
//  ğŸ’¡ æ˜“æ‡‚è§£é‡Š:
//      å‘Šè¯‰æµè§ˆå™¨ï¼š"æ¯æ¬¡éƒ½æ¥é—®æˆ‘è¦æœ€æ–°çš„æ–‡ä»¶ï¼Œåˆ«ç”¨æ—§çš„ï¼"
// =============================================================================
async fn no_cache_middleware(request: Request<Body>, next: Next) -> Response {
    let mut response = next.run(request).await;
    
    // ğŸ›¡ï¸ ä¸º JS/CSS æ–‡ä»¶æ·»åŠ ç¦ç”¨ç¼“å­˜å¤´
    response.headers_mut().insert(
        header::CACHE_CONTROL,
        "no-cache, no-store, must-revalidate".parse().unwrap()
    );
    response.headers_mut().insert(
        header::PRAGMA,
        "no-cache".parse().unwrap()
    );
    response.headers_mut().insert(
        header::EXPIRES,
        "0".parse().unwrap()
    );
    
    response
}

// =============================================================================
//  ğŸ‰ ä¸»å‡½æ•° (æ— )
//
//  ğŸ¨ ç”¨é€”:
//      å¯åŠ¨é™æ€æ–‡ä»¶æœåŠ¡å™¨ã€‚
//
//  ğŸ’¡ æ˜“æ‡‚è§£é‡Š:
//      "å¼€é—¨è¥ä¸šï¼Œæ¬¢è¿å…‰ä¸´ï¼"
//
//  âš ï¸ è­¦å‘Š:
//      é»˜è®¤ç›‘å¬ 3000 ç«¯å£ï¼Œå¦‚æœè¢«å ç”¨ä¼š Panicã€‚
//
//  âš™ï¸ è§¦å‘æº:
//      cargo run --bin simple_server
// =============================================================================
#[tokio::main]
async fn main() {
    // 1. åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt::init(); // ğŸ“¢ æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–

    println!("ğŸ“‚ [Rust Low] æ­£åœ¨å¯åŠ¨é™æ€æ–‡ä»¶æœåŠ¡..."); // ğŸ“¢ å¯åŠ¨æ—¥å¿—

    // 2. æ„å»ºè·¯ç”± (ä»…é™æ€æ–‡ä»¶)
    // ğŸ“‚ æ ¹è·¯å¾„æ˜ å°„åˆ°å½“å‰å·¥ä½œç›®å½•
    // âš ï¸ Axum 0.8 å˜æ›´: æ ¹è·¯å¾„ä¸å†æ”¯æŒ nest_serviceï¼Œæ”¹ç”¨ fallback_service
    let app = Router::new()
        .fallback_service(ServeDir::new(".")) // ğŸ“‚ é™æ€æ–‡ä»¶æœåŠ¡ (Axum 0.8+)
        .layer(middleware::from_fn(no_cache_middleware)) // ğŸ›¡ï¸ ç¦ç”¨ç¼“å­˜ä¸­é—´ä»¶
        .layer(CorsLayer::permissive()); // ğŸ›¡ï¸ CORS ç­–ç•¥ (å…è®¸æ‰€æœ‰)

    // 3. å¯åŠ¨æœåŠ¡å™¨
    let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); // ğŸ¯ ç»‘å®šåœ°å€
    println!("ğŸš€ [Rust Low] é™æ€èµ„æºæœåŠ¡å™¨ç›‘å¬ä¸­: http://{}", addr); // ğŸ“¢ ç›‘å¬æ—¥å¿—
    
    // ğŸ§± [2025-12-17] ä¿®å¤: æ·»åŠ é”™è¯¯å¤„ç†ï¼Œé˜²æ­¢æœåŠ¡å™¨å› ç«¯å£ç»‘å®šå¤±è´¥è€Œå´©æºƒ
    let listener = match tokio::net::TcpListener::bind(addr).await {
        Ok(l) => l,
        Err(e) => {
            eprintln!("âŒ [Rust Low] ç«¯å£ç»‘å®šå¤±è´¥: {}", e);
            eprintln!("ğŸ’¡ æç¤º: ç«¯å£ 3000 å¯èƒ½è¢«å ç”¨ï¼Œè¯·æ£€æŸ¥å¹¶é‡Šæ”¾ç«¯å£");
            return;
        }
    };
    
    // å¯åŠ¨æœåŠ¡å™¨ï¼Œå¦‚æœå‡ºé”™åˆ™æ‰“å°é”™è¯¯ä¿¡æ¯
    if let Err(e) = axum::serve(listener, app).await {
        eprintln!("âŒ [Rust Low] æœåŠ¡å™¨é”™è¯¯: {}", e);
    }
}
