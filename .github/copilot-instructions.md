# 🤖 000AI 自动化执行协议 (Autonomous Execution Protocol)

**⚠️ 最高优先级 (Prime Directives)**:
1.  **⚓ 协议锚定 (Protocol Anchoring)**: 每当开始一个新的复杂任务时，必须重新索引并锁定本协议的核心步骤，防止因上下文漂移而偏离规范。
2.  **🔄 自主闭环 (Autonomous Loop)**: 严格遵循流程 **1. 🎯 需求实现** -> **2. 🛠️ 自主修复与验证** -> **3. 📝 注释专家** -> 交付。
    *   **⚠️ 同步约束**: 在 **步骤 2** 执行期间，必须**同步执行** [🔁 迭代即时日志] 协议。每修复一个错误或进行一次验证，必须立即写入日志，**严禁**在任务结束时一次性补录。
    *   **🚫 零交互**: 任务完成前**严禁**请求用户确认。
3.  **🤐 零交互 (Zero Interaction)**: 所有命令必须静默执行 (`-y`, `--no-input`)。交互式脚本必须使用管道注入输入。
4.  **💾 抗遗忘 (Context Persistence)**: 无论对话多长，必须严格遵守“注释专家”规范。
5.  **💰 算力连续性策略 (Compute Continuity Strategy)**: 允许消耗 Token 进行深度推理。若输出内容过长，**必须主动分段输出**，防止物理截断导致逻辑中断。
6.  **🧹 零残留承诺 (Zero Residue Commitment)**: 严格执行 **[资源与环境协议]**，确保任何由 AI 创建的文件都有“出生证明”和“死亡证明”。断电重启后，必须优先处理遗留垃圾。

---

## 🛡️ 资源与环境协议 (Resource & Environment Protocols)

**1. 📜 资源分配表 (Resource Allocation Table)**
*   **文件位置**: `Debug/Trash/000AI_Resource_Manifest.json` (持久化存储)。
*   **写入时机**: 在**创建任何临时文件之前**，或预判代码会生成文件时，**必须先写入**此注册表。
*   **内容格式**: `{"target_path": "...", "origin": "test_script_A", "status": "active"}`。

**2. 💾 断电恢复 (Crash Recovery)**
*   **启动检查**: 每次启动新对话时，**必须**首先检查 `Debug/Trash/000AI_Resource_Manifest.json`。
*   **强制归档**: 若发现 `status: "active"` 的残留文件，立即将其移动到 `Debug/Trash/Recovered_<Date>/`，确保工作区复原。

**3. 🧹 闭环回收 (Loop Recycling)**
*   **触发时机**: 任何 **Step 2 (验证阶段)** 结束时，或任务完成时。
*   **执行动作**:
    *   读取注册表，将所有临时文件移动到 `Debug/Trash/<YYYYMMDD>/<Step_Name>/`。
    *   **根目录扫尾**: 额外扫描根目录下的 `test_*`, `*.log`, `temp_*`，防止漏网之鱼。
*   **📝 回收审计 (Recycle Audit)**: 
    *   必须在 `Debug/Trash/<YYYYMMDD>/Recycle_Log.json` 中追加记录每一次回收操作的详细清单。
    *   格式: `{"timestamp": "...", "recycled_files": ["file_A", "file_B"], "destination": "..."}`。
*   **🚫 豁免名单**: `.lnk` (快捷方式) 文件严禁回收，必须保留在原位。

**4. 🛡️ 编码与命名安全 (Encoding & Naming Safety)**
*   **乱码清理**: 必须定期扫描并删除根目录下因编码错误产生的乱码文件/文件夹 (如 `楠岃瘉缁撴灉`, `验证结果` 等)。
*   **保留字规避**: 严禁创建名为 `nul`, `con`, `prn`, `aux`, `com1` 等 Windows 保留字的文件。若发现，必须使用 `\\.\` 路径前缀强制删除。

---

## 📝 审计与日志协议 (Audit & Logging Protocols)

**1. 实时日志 (Live Logging)**
*   **文件位置**: `000AI_Copilot_WorkLog.md`。
*   **强制记录**: **每一次 '修复-验证' 循环 (Repair-Verify Cycle) 结束后**，或**完成一个具体功能点后**，必须立即更新日志。特别是在 **Step 2** 阶段，每尝试一个新方案或修复一个 BUG，无论成功与否，都必须即时记录。**严禁**在未写日志的情况下直接回复用户“已完成”。
*   **历史保护**: **严禁**删除或清空旧的日志记录。
*   **内容要求**: 记录新的发现、修复方案或验证结果。
*   **待办追踪**: 日志末尾必须明确列出**当前发现的新问题**，并标记为 `[待解决]` 状态，防止遗忘。

---

## 🔄 核心工作流 (The 3-Step Loop)

### 1. 🎯 需求实现 (Implementation)
*   **行动**: 编写或修改代码以满足功能需求。
*   **标准**: **高评分紧凑代码 (High-Score Compact Code)**。
    *   **核心目标**: 追求代码在 **健壮性、性能、解耦度** 上的最高评分 (High Logic Score)。
    *   **必须**:
        *   **强类型约束**: 全面使用 Type Hints / Interfaces，确保类型安全。
        *   **极简命名 (Minimalist Naming)**: **强制**变量/函数名最多包含 **1 个下划线** (例如 `userid`, `data_list`, `process`). 牺牲 PEP8 规范以换取极致的 Token 效率和紧凑度。
        *   **原子化设计**: 单一职责原则，拒绝“上帝函数”。
    *   **禁止**: 任何形式的自然语言注释（包括 Docstrings）。
*   **目的**: 产出逻辑评分极高但体积极小的代码，为阶段 2 提供最佳底座。

### 2. 🛠️ 自主修复与验证 (Autonomous Repair & Verification)
*   **定义**: 这是**全自动修复 BUG 并验证成功的阶段**。必须在本地沙盒环境中，完全无需人工监督，直到代码真正成功运行。
*   **触发**: 代码编写完成后，**立即自动进入**。
*   **行动**: 在 `Debug/Trash/<YYYYMMDD>/` 创建临时测试脚本并**在终端实际运行**。
*   **核心规则**:

    1.  **🛡️ 隔离沙盒执行 (Isolated Sandbox Execution)**:
        *   **注册义务**: 所有临时文件必须注册到 **[资源分配表]**。
        *   **真实性**: 严禁仅在“思维链”中模拟，必须看到真实的终端输出。
        *   **隔离性**: 所有临时文件必须存入 `Debug/Trash/<YYYYMMDD>/`，防止污染主工作区。

    2.  **🤐 零交互执行 (Zero-Interaction Execution)**:
        *   **强制静默**: 启动命令必须携带自动确认参数（如 `-y`, `--no-input`）。
        *   **🔍 交互扫描 (Interaction Scan)**: 在运行任何脚本前，**必须**先读取文件内容，搜索 `set /p`, `choice`, `read`, `input()`。
        *   **管道注入**: 若发现交互命令，**严禁**直接运行。必须使用管道（如 `echo "1" | script.bat`）或输入重定向文件来预先注入所有可能的输入。
        *   **违规即失败**: 任何导致终端出现“等待输入光标”的操作，均视为测试失败，需立即修正启动方式。
        *   **🚫 禁用暂停 (No Pause)**: 在测试脚本中，**严禁**使用 `pause`、`read`、`input()` 等等待用户输入的命令。如果必须测试交互逻辑，必须使用 `timeout /t 1 >nul` 代替 `pause`，或通过管道自动输入。

    3.  **🚫 阻塞检测 (Blocking Detection)**:
        *   **现象**: 程序启动后 **20 秒内** 无新输出，或输出包含 `[y/n]`, `Select`, `Enter`, `?`, `>` 等等待提示符。
        *   **判定**: 视为**交互阻塞**或**进程假死**。
        *   **处置**: **立即终止进程 (Kill)**。**绝不允许**傻等全局时限（20分钟）耗尽。

    4.  **🚑 故障自愈 (Self-Healing)**:
        *   **分析-修复-重启**: 针对报错或阻塞原因，**修改代码逻辑**或**调整启动命令**。
        *   **🏛️ 架构完整性 (Architectural Integrity)**: 修复 BUG 时，**严禁**为了追求速度而使用“脏修补” (Dirty Hacks)。必须维持阶段 1 的高评分逻辑，确保**最终交付的代码**在评分上不降级。
        *   **Token 节约**: 此阶段**严禁**添加装饰性注释，仅保留调试必要的打印信息，以节省 Token 并加快迭代。

    5.  **🏁 退出机制 (Exit Strategy)**:
        *   **全局时限**: **20 分钟**。这是为了防止无限循环的硬性熔断。
        *   **成功标准**: 代码无报错、无阻塞、且**输出符合预期结果**。
        *   **终止条件**: 达成成功标准，或时间耗尽。

    6.  **📝 实时记录 (Real-time Logging)**:
        *   **强制动作**: 每次尝试修复或运行测试后，必须立即在 `000AI_Copilot_WorkLog.md` 中记录结果。
        *   **严禁**: 严禁在所有尝试结束后一次性补录日志。

### 3. 📝 注释专家 (The Comment Expert)
*   **触发**: 仅在阶段 2 **验证成功后**执行。
*   **豁免**: **.bat (Batch) 文件**。因 Batch 脚本在代码块中使用 `::` 注释会导致语法崩溃，故**跳过**对此类文件的注释注入，仅允许在文件头添加说明。
*   **核心任务**: **逆向工程与文档注入 (Reverse Engineering & Documentation Injection)**。
    *   **第一步 (理解)**: 深度阅读阶段 2 验证通过后的**最终代码**，理解其经过修复后的业务逻辑和设计意图。
    *   **第二步 (注入)**: 基于对最终代码的理解，注入“五段式备注”和“逐行 Emoji 注释”，**严禁**修改任何代码逻辑。
    *   **质量保障**: 注释必须解释“Why” (设计意图) 而非简单的翻译代码。
*   **分块策略 (Chunking Strategy)**:
    *   若文件超过 50 行，**严禁**一次性全量输出。
    *   **必须**分块处理（例如每次处理 20-30 行），使用 `replace_string_in_file` 逐步应用注释。
    *   防止因输出过长导致模型“偷懒”或被物理截断。

#### 📜 注释规范 (Strict Standards)

**A. 文件头 (File Header)**
*   **位置**: 文件最顶部。
*   **格式**:
    ```text
    /* ==========================================================================
       📃 文件功能 : [写全]
       ⚡ 逻辑摘要 : [核心算法/思路]
       💡 易懂解释 : [高中生能懂，正面可爱语气，不使用比喻]
       🔋 扩展备注 : [未来扩展建议]
       🧱 [当前文件名] 踩坑记录 (必须累加，严禁覆盖) :
          1. [YYYY-MM-DD] [坑名]: [原因] -> [修复方案] (Line XX)
       ========================================================================== */
    ```

**B. 五段式备注 (The 5-Part Block)**
*   **适用**: 函数、类、模块、HTML容器。
*   **位置**: 定义行的下一行（内部）。
*   **必填**:
```text
// =============================================================================
//  🎉 [中文含义] ([参数的中文含义]，[参数的中文含义]，[参数的中文含义]，...)
//
//  🎨 代码用途：
//      [专业描述：精准的编程术语，描述这段代码的技术目，但要易懂]
//
//  💡 易懂解释：
//      [高中生能懂，正面可爱语气，不使用比喻]
//  
//  ⚠️ 警告：
//      [风险类型]: [具体后果与解决方案]
//      (例如：死锁隐患、内存溢出、数据一致性等。若无特殊风险，写“无特殊风险”)
//  
//  ⚙️ 触发源 (Trigger Source)：
//      [文件/模块] -> [UI交互/事件] -> [函数调用链]
//      (例如：通过 admin_panel.js 后台管理系统的 “强制结算” 按钮 handle_click(参数名,参数名,) -> Admin_Force_Settle(参数名,参数名,) 触发)
// =============================================================================
```

**C. 📍 视觉状态信标 (Visual State Beacons)**
*   **定义**: 优先选用正面、可爱的 Emoji作为**视觉信标**，将代码逻辑映射为人类可读的语义块。
*   **覆盖率**: **100%** (除纯括号外)。每一行代码必须有信标。
*   **内容**: **状态/结果导向 (State/Result Oriented)**。
    *   侧重描述代码执行后的 **“状态变化”** 或 **“业务结果”**。
    *   **严禁**使用逗号、长句或“初始化为...”等废话。
    *   **风格**: 词汇偏名词化，简洁有力，像仪表盘的状态灯。
*   **语法适配**: 自动识别 `.py` (#), `.js` (//), `.bat` (REM), `.html` (<!-- -->)。
    *   **特殊规则**: 对于 `.bat` (Batch) 文件，**严禁**在 `if` 或 `for` 代码块内部使用 `::` 风格注释，必须强制使用 `REM`，否则会破坏语法结构。

**示例**:
```python
def calculate_score(points):
    # ... (此处必须有完整的五段式备注) ...
    current_score = 0  # 🥚 基础分归零
    if points > 10:    # ⚖️ 高分阈值判定
        current_score = points * 2  # 🚀 双倍奖励生效
    return current_score # 📤 最终结果交付
```
