class EventBus {
    // ---------------------------------------------------------------- //
    //  事件总线类()
    //
    //  函数用处：
    //     实现发布-订阅模式 (Publish-Subscribe Pattern)，用于模块间解耦通信。
    //
    //  易懂解释：
    //     这是一个“广播站”。
    //     - 模块A说：“我要订阅‘吃饭’这个频道”。(on)
    //     - 模块B说：“广播一下，‘吃饭’啦，今天是红烧肉！” (emit)
    //     - 模块A就收到了消息，知道今天是红烧肉。
    //     模块A和模块B不需要互相认识，只需要都认识广播站就行。
    //
    //  警告：
    //     如果事件名拼写错误，订阅者将永远收不到消息，且不会报错。
    // ---------------------------------------------------------------- //
    constructor() {
        // 存储所有事件监听器的字典
        // 格式: { 'event_name': [callback1, callback2, ...] }
        this.listeners = {};
    }

    on(event, callback) {
        // ---------------------------------------------------------------- //
        //  监听(事件名, 回调函数)
        //
        //  函数用处：
        //     订阅一个事件。当该事件被触发时，执行回调函数。
        //
        //  易懂解释：
        //     告诉广播站：“如果听到这个频道的消息，就马上通知我”。
        //
        //  警告：
        //     callback 必须是一个函数。如果传入其他类型，触发时会报错。
        // ---------------------------------------------------------------- //

        // 如果这个事件还没有人订阅过，先创建一个空数组
        if (!this.listeners[event]) {
            this.listeners[event] = [];
        }
        // 把回调函数加入数组
        this.listeners[event].push(callback);
    }

    emit(event, data) {
        // ---------------------------------------------------------------- //
        //  触发(事件名, 数据)
        //
        //  函数用处：
        //     发布一个事件。所有订阅了该事件的回调函数都会被执行。
        //
        //  易懂解释：
        //     拿着大喇叭喊话。所有在听这个频道的人都能听到。
        //
        //  警告：
        //     这是同步执行的。如果某个回调函数执行时间过长，会卡住主线程。
        // ---------------------------------------------------------------- //

        // 检查是否有监听者
        if (this.listeners[event]) {
            // 遍历所有回调函数并执行，把数据传给它们
            this.listeners[event].forEach(callback => callback(data));
        }
    }

    off(event, callback) {
        // ---------------------------------------------------------------- //
        //  取消监听(事件名, 回调函数)
        //
        //  函数用处：
        //     取消订阅。
        //
        //  易懂解释：
        //     告诉广播站：“我不听这个频道了，别再烦我”。
        //
        //  警告：
        //     必须传入与 on 时完全相同的函数引用才能成功移除。匿名函数无法被移除。
        // ---------------------------------------------------------------- //

        if (!this.listeners[event]) return;
        // 过滤掉要移除的那个回调函数
        this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
    }
}

// 导出单例，确保全站共用一个广播站
export const bus = new EventBus();